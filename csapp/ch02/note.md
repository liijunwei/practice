+ 最重要的三种数字表示
    + 无符号 unsigned编码
    + 补码 two's-complement编码
    + 浮点数floating-point编码

+ 大多数计算机使用8位的块(1byte), 作为最小的可寻址的内存单位, 而不是访问内存中单独的位
+ 机器中程序将内存视为一个非常大的字节数组, 成为"虚拟内存(virtual memeory)"
+ 内存中的每个字节都由一个唯一的数字来标识, 称为它的地址(address), 所有可能地址的集合就成为"虚拟地址空间(virtual address space)"
+ 顾名思义, 这个虚拟地址空间只有一个展现给机器级程序的概念性映像
+ 实际的实现(第九章)是将动态随机访问存储器(DRAM)/内存/磁盘存储器/特殊硬件/操作系统软件结合起来, 微程序提供一个看上去统一的字节数组

+ 在接下来的几章中, 会涉及编译器和运行时系统是如何将存储器空间划分为更可管理的单元, 来存储不同的程序对象(program object)
    + 程序数据
    + 指令
    + 控制信息

## 2.1.2 字数据大小

+ 每台计算机都有一个字长(word size), 指明指针数据的标称大小(nominal size)
+ 因为虚拟地址是以这样的一个字来编码的, 所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小
    + 对一个自常委w位的机器而言, 虚拟地址的范围是0-(2^w - 1), 程序最多访问2^w个字节
```ruby
(2 ** 32 - 1) * 1.0 / 1024 / 1024 / 1024
=> 3.9999999990686774
(2 ** 64 - 1) * 1.0 / 1024 / 1024 / 1024
=> 17179869184.0
```

## 2.1.3 寻址和字节顺序

+ 对于跨越多个字节的程序对象(program object), 我们必须建立两个规则
    1. 这个对象的地址是什么?
    2. 在内存中如何排列这些字节?

+ 小端法(little endian)
+ 大端法(big endian)

```
1Byte => 8bit 0000 0000 => 0x00 0x00
              1111 1111 => 0x11 0x11

一个字节 可以用两个16进制数字表示
```

+ 选择何种字节顺序没有技术上的理由
+ 只要选择了一种规则并且始终如一地坚持, 对于那种字节排序的选择都是任意的

+ [图2-4](./showbytes.c)

+ 可以观察到, 尽管浮点型和整型数据都是对值12345进行编码, 但是他们有截然不同的字节模式
```
 39 30 00 00 (int)
 00 e4 40 46 (float)
```

## 2.1.5 表示代码

+ 二进制代码是不兼容的
+ 计算机系统的一个基本概念就是: 从机器的角度来看, 程序仅仅只是字节序列

## 2.1.6 布尔代数(boolean algebra)简介

+ Geroage Boole

+ 二进制值是计算机 编码/存储/操作 信息的核心

+ 布尔环(boolean ring)

+ 布尔环与整数运算有很多相同的属性
    + 例如: 证书晕眩的一个属性时每个值为`x`都有一个**加法逆元(additive inverse)**`-x`, 使得 `x + (-x) = 0`
    + 布尔环 也有这种属性, 这里的**加法**指的是`^`(XOR), 这是的加法逆元是他自己本身, 即 对任何值来说, `a^a=0`, 这里用0向量表示全0的位向量

+ 问题: 为什么 `(a^b)^a = b` ???
    + 一个向量和0向量做XOR运算的结果是这个向量本身, 这个0向量什么也没干...

```
10011101
00000000 ^
------------
10011101
```



## 2.1.7 C语言中的位级运算

+ 确定一个位级表达式的结果最好的方法是: 将十六进制的参数扩展成二进制并执行二进制运算, 然后再转成十六进制


## 2.1.8 C语言中的逻辑运算

+ 逻辑运算很容易和位级运算搞混, 但他们的功能是完全不同的
+ 逻辑运算认为所有非零参数都表示TRUE, 而参数0表示FALSE, 他们返回0或1, 分别表示TRUE或FALSE

+ 按位运算只有在特殊情况下, 也就是参数被限制为0或者1时,才和与其对应的逻辑运算有相同的行为


## 2.1.9 移位运算

unclear

+ 算术移位
+ 逻辑移位

## 2.2.2 无符号数的编码

+ 向量真是一个好概念啊
+ 原理: 无符号数编码的唯一性

+ B2Uw 二进制到无符号数
+ U2Bw 无符号数到二进制
+ (函数与反函数)


## 2.2.3 补码编码

+ B2T binary to two's-complement

+ 有符号数的表示方法
    + 补码
    + 反码 One's Complement
    + 原码 Sign-Magnitude






