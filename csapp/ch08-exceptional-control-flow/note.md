异常控制流
===============

2022-08-27 15:25:04

+ 异常控制流 Excptional Control Flow(ECF)

+ 异常控制流发生在计算机系统的各个层次
    + 硬件层
    + 操作系统层
    + 应用层

+ trap/system-call 都算 ECF

+ 本章的重要性在于你将开始学习应用是如何与操作系统交互的; 有趣的是, 这些交互都是围绕着ECF的

+ man 7 signal

+ 一个为负的PID会导致信号被发送到进程组PID中的每个进程
    + kill -9 -15213

## 8.5 信号

+ linux信号 允许进程和内核终端其他进程

+ 一个信号就是一条小消息, 他通知其他进程系统中发生了一个某种类型的事件
+ 每种信号类型都对应于某种系统事件


### 8.5.1 信号术语

+ 传送一个信号到目的进程 由两个步骤组成
    1. 发送信号: 内核通过更新目的进程上下文中的某个状态, 发送一个信号给目的进程
        + 原因.1 内核检测到一个系统事件(例如 除零错误/子进程终止)
        + 原因.2 一个进程调用了kill函数, 显式要求内核发送一个信号给目的进程, 可以是进程自身
    2. 接收信号: 当目的进程被内核强迫以某种方式对信号的发送做出反应时, 他就接受了信号; 进程可以忽略这个信号, 终止或者通过执行一个称为"信号处理函数"(signal handler)的用户层函数捕获这个信号

+ 一个发出而没被接收的信号叫做 "待处理信号(pending signal)"
+ 在任何时刻, 一种类型至多只会有一个待处理信号; 如果一个进程有一个类型为k的待处理信号, 那么任何接下来发送到这个进程的类型为k的信号都不会排队等待; 他们只是被简单的丢弃


+ 什么意思??? "一个进程可以有选择性地阻塞接收某种信号; 当一种信号被阻塞时, 它仍可以被发送, 但是产生的待处理信号不会被接收, 知道进程取消对这种信号的阻塞"
    + TODO 做实验,应该好懂

+ 一个待处理信号最多只能被接收一次

### 8.5.2 发送信号

+ unix shell的一条命令执行过程中, 在任意时刻, 至多只有1个前台作业和0个或多个后台作业
    + `ls | sort`

+ 键盘输入 ctrl+c 会导致内核发送一个SIGINT信号到前台进程组中的每一个进程; 默认情况下, 结果是终止前台作业

### 8.5.3 接收信号

```c
#include "signal.h"

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

+ signal函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为:
    1. 如果handler是 `SIGIGN`(sig ignore), 那么忽略类型为signum的信号
    2. 如果handler是 `SIGDEL`(sig default), 那么类型为signum的信号行为回复为默认行为
    3. handler是用户定义的函数的地址, 这个函数被称为"信号处理程序", 只要进程接收到一个类型为signum的信号, 就会调用这个程序; 通过把程序的地址传递到signal函数从而改变默认行为, 这叫做设置信号处理程序("installing the handler"). 调用信号处理程序被称为捕获信号, 执行信号处理程序叫做处理信号

+ 信号处理程序可以被其他信号处理程序中断

### 8.5.4 阻塞和解除阻塞信号

+ linux提供阻塞信号的 隐式 和 显式的机制
    1. 隐式阻塞机制: 内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号(太绕啦, 结合图8-31理解)
    2. 显式阻塞机制: 应用程序可以使用`sigprocmask`函数和他的辅助函数, 明确地阻塞和解除阻塞选定的信号


+ 一些保守的编写处理程序的原则, 使得这些处理程序能安全地并发运行
    + G0: 处理程序要尽可能简单
    + G1: 在处理程序中只调用异步信号安全的函数

+ TODO 问题: "一步信号安全的函数" 和 "线程安全" 有什么关系?

+ 信号处理程序中产生输出唯一安全的方法是使用write函数(`man 2 write`)

+ SIO 包






