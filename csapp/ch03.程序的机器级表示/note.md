+ 计算机执行机器代码, 用字节序列编码低级的操作, 包括
    + 处理数据
    + 管理内存
    + 读写存储设备上的数据
    + 利用网络通信

+ 本章中会近距离观察机器代码, 以及人类可读的表示---汇编代码

+ 通常情况下, 使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效

+ 高级语言编写的代码因为屏蔽了程序的的细节, 机器级的实现, 所以有较好的跨平台能力
+ 汇编代码则与特定机器密切相关

+ 能够阅读和理解汇编代码是一项重要技能: 编译器以汇编代码形式输出文件, 通过阅读这些汇编代码, 我们能够理解编译器的优化能力, 并分析代码中隐含的低效率
    + **试图最大化一段关键代码性能的程序员, 通常会尝试源代码的各种形式, 每次编译并检查产生的汇编代码, 从而了解程序将要运行的效率如何**

+ 程序员学习汇编语言的需求随着时间的推移也发生了变化, 开始时要求能直接用汇编语言编写程序, 现在则要求他们能够阅读和理解编译器产生的代码

+ C语言/汇编代码/机器代码之间的关系


# 3.1 历史观点

+ 摩尔定律(Moore's Law)
    + 晶体管数量以每年大约37%的速率增加, 也就是说 晶体管数量没26个月就会翻一番
    + 1965年, 摩尔根据当时芯片技术做出推断, 预测未来十年, 芯片上的晶体管数量每年都会翻一番, 这个预测就成为摩尔定律

# 3.2 程序编码

## 3.2.1 机器级代码

+ 计算机系统使用了多种不同形式的抽象, 利用更简单的抽象模型来隐藏实现的细节

+ 对于机器级编程来说, 其中两种抽象尤为重要:
    1. 由指令集体系结构或指令集架构(Instruction Set Architecture, ISA)来定义机器级程序的格式和行为, 它定义了处理器状态,指令的格式,每条指令对状态的影响
    2. 机器级程序使用的内存地址是虚拟地址, 提供的内存模型看上去是一个非常大的字节数组

+ 汇编代码表示非常接近于机器代码. 与机器代码的二进制格式相比, 汇编代码的主要特点是他用可读性更好的文本格式表示; 能够理解汇编代码以及它与原始C代码的联系, 是理解计算机如何执行程序的关键一步

page 113
+ 程序计数器PC
+ 整数寄存器文件
+ 条件寄存器
+ 一组向量寄存器

+ 程序内存包含什么部分(page 114)

+ 一条机器指令只执行一个非常基本的操作

## 3.2.2 代码示例

csapp/ch03.程序的机器级表示/mstore.c

```bash
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -S mstore.c && cat mstore.s
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -c mstore.c && ls -al mstore.o
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -c mstore.c && objdump -d mstore.o

practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -o prog main.c mstore.c
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -o prog main.c mstore.c && objdump -d prog


```

+ 重要信息: 机器执行的程序只是一个字节序列, 它是对一系列指令的编码; 机器对产生这些指令的源代码几乎一无所知


## 3.2.3 关于格式的注解

```
_multstore:                             ## @multstore
## %bb.0:
  pushq %rbp                    # save %rbx
  movq  %rsp, %rbp              # copy dest to %rbx
  pushq %rbx
  pushq %rax
  movq  %rdx, %rbx
  callq _mult2                  # call mult2(x, y)
  movq  %rax, (%rbx)            # store result at *dest
  addq  $8, %rsp
  popq  %rbx                    # restore %rbx
  popq  %rbp
  retq                          # return
                                        ## -- End function
```

# 3.4 访问信息

+ page 119 寄存器

+ x86-64 CPU 一组16个寄存器, 每个寄存器64位, 用来存储整数数据和指针

+ 有一组标准的编程规范控制着如何使用寄存器来管理栈, 传递函数参数, 从函数的返回值一级存储局部和临时变量...

## 3.4.1 操作数指示符

+ 大多数指令有一个或多个操作数(operand), 指示出一个操作数中要使用的 `源数据值` 以及 `放置结果的目的位置`

+ 源数据可以以常数形式给出, 或者从寄存器或内存中读出

+ 结果可以存放到寄存器或内存中

+ 各种不同操作数的可能性
    1. 立即数(immediate), 常数值
    2. 寄存器(register), 某个寄存器的内容
    3. 内存引用, 根据计算出来的地址访问某个位置

+ 寻址模式(page 121)

+ 立即数偏移
+ 基址寄存器
+ 变址寄存器
+ 比例因子

## 3.4.2 数据传送指令

+ 最常用的指令是将数据从一个位置复制到另一个位置的指令

+ 最简单的数据传送指令: MOV类, 他们把数据从源位置传送到目的位置, 不做任何变化

+ 源操作数指定的是一个立即数, 存在寄存器或者内存里
+ 目的操作数制定一个位置, 要么是寄存器, 要么是内存地址
+ x86-64加了一条限制: 传送指令的两个操作数不能都指向内存位置
    + i.e. 将一个值从内存地址1复制到内存地址2, 需要两条指令

+ MOV指令的 元和目的类型的5种可能的组合(page 123)
    1. 立即数 - 寄存器
    2. 寄存器 - 寄存器
    3. 内存   - 寄存器
    4. 立即数 - 内存
    5. 寄存器 - 内存

+ movl $ox4050, %eax
    + 第一个是 源操作数
    + 第二个是 目的操作数

```s
movzbw
movzbl
movzwl
movzbq
movzwq
```

+ 每条指令的最后两个字符都是大小指示符
    + 第一个指示 源的大小
    + 第二个指示 目的地的大小

+ x86-64中的内存引用总是用四字长(64bit)寄存器给出, 例如 %rax, 哪怕操作数指示一个字节/一个字/一个双字(page 227)
    + page 120
    + page 124 练习题 3.2

## 3.4.3 数据传送示例

+ https://stackoverflow.com/questions/42619995/running-assembly-code-for-mac-os-x
+ https://www.nasm.us/

+ [page 125 example](./exchange.c)
+ csapp/ch03.程序的机器级表示/exchange_demo.c

```s
_exchange:                              ## @exchange
## %bb.0:
  pushq %rbp
  movq  %rsp, %rbp
  movq  (%rdi), %rax
  movq  %rsi, (%rdi)
  popq  %rbp
  retq
                                        ## -- End function
```




















