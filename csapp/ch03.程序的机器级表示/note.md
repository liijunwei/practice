+ 计算机执行机器代码, 用字节序列编码低级的操作, 包括
    + 处理数据
    + 管理内存
    + 读写存储设备上的数据
    + 利用网络通信

+ 本章中会近距离观察机器代码, 以及人类可读的表示---汇编代码

+ 通常情况下, 使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效

+ 高级语言编写的代码因为屏蔽了程序的的细节, 机器级的实现, 所以有较好的跨平台能力
+ 汇编代码则与特定机器密切相关

+ 能够阅读和理解汇编代码是一项重要技能: 编译器以汇编代码形式输出文件, 通过阅读这些汇编代码, 我们能够理解编译器的优化能力, 并分析代码中隐含的低效率
    + **试图最大化一段关键代码性能的程序员, 通常会尝试源代码的各种形式, 每次编译并检查产生的汇编代码, 从而了解程序将要运行的效率如何**

+ 程序员学习汇编语言的需求随着时间的推移也发生了变化, 开始时要求能直接用汇编语言编写程序, 现在则要求他们能够阅读和理解编译器产生的代码

+ 总览
    + C语言/汇编代码/机器代码之间的关系
    + x86-64的细节, 从数据的表示和处理以及控制的实现开始, 了解如何实现C语言中的控制结构(if/while/switch等)
    + 过程的实现, 如何维护一个运行栈来支持过程检数据和控制的传递, 局部变量的存储
    + 机器级怎么实现数组/结构/联合等数据结构
    + 内存越界问题
    + 使用GDB调试器检查机器级程序运行时行为的技巧
    + 包含浮点数据和操作的代码的及其程序表示


# 3.1 历史观点

+ 摩尔定律(Moore's Law)
    + 晶体管数量以每年大约37%的速率增加, 也就是说 晶体管数量没26个月就会翻一番
    + 1965年, 摩尔根据当时芯片技术做出推断, 预测未来十年, 芯片上的晶体管数量每年都会翻一番, 这个预测就成为摩尔定律

# 3.2 程序编码

## 3.2.1 机器级代码

+ 计算机系统使用了多种不同形式的抽象, 利用更简单的抽象模型来隐藏实现的细节

+ **对于机器级编程来说, 其中两种抽象尤为重要**:
    1. 由指令集体系结构或指令集架构(Instruction Set Architecture, ISA)来定义机器级程序的格式和行为, 它定义了处理器状态,指令的格式,每条指令对状态的影响
        + 大多数指令集架构(ISA) 将程序的行为描述成好像每条指令都是按顺序执行的, 一条指令结束后, 下一条才开始
        + 处理器的硬件远比描述的精细复杂, 他们并发地执行许多指令, 但是可以采取措施保证整体行为和ISA指定的顺序执行的行为完全一致
    2. 机器级程序使用的内存地址是虚拟地址, 提供的内存模型看上去是一个非常大的字节数组

ISA 指令集架构
ISA 指令集架构
ISA 指令集架构 指令集架构指令集架构指令集架构指令集架构

+ 机器代码, 二进制格式
+ 汇编代码, 文本格式

+ 汇编代码表示非常接近于机器代码. 与机器代码的二进制格式相比, 汇编代码的主要特点是他用可读性更好的文本格式表示;

+ 能够理解汇编代码以及它与原始C代码的联系, 是理解计算机如何执行程序的关键一步


p113
+ 程序计数器PC: 给出将要执行的下一条指令在内存中的地址
+ 整数寄存器文件: 存储地址/存储整数数据/记录程序状态/存储临时数据(参数/变量/返回值...)
+ 条件寄存器: 保存最近执行的算数或逻辑指令的状态信息, 实现程序中的 控制流
+ 一组向量寄存器: 存放一个或多个整数或者浮点数值

+ 程序内存包含什么部分(p114)

+ 一条机器指令只执行一个非常基本的操作

## 3.2.2 代码示例

csapp/ch03.程序的机器级表示/mstore.c

```bash
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -S mstore.c && cat mstore.s
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -c mstore.c && ls -al mstore.o
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -c mstore.c && objdump -d mstore.o

practice && cd csapp/ch03.程序的机器级表示/ && make main_demo
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -o prog main.c mstore.c && objdump -d prog

```

+ 重要信息: 机器执行的程序只是一个字节序列, 它是对一系列指令的编码; 机器对产生这些指令的源代码几乎一无所知


## 3.2.3 关于格式的注解

```
_multstore:                             ## @multstore
## %bb.0:
  pushq %rbp                    # save %rbx
  movq  %rsp, %rbp              # copy dest to %rbx
  pushq %rbx
  pushq %rax
  movq  %rdx, %rbx
  callq _mult2                  # call mult2(x, y)
  movq  %rax, (%rbx)            # store result at *dest
  addq  $8, %rsp
  popq  %rbx                    # restore %rbx
  popq  %rbp
  retq                          # return
                                        ## -- End function
```

# 3.3 数据格式

+ 由于是从16位体系扩展成32位的, **Intel用术语"字(word)"表示16位数据类型**
+ 因此:
    + 称32位数为 "双字(double word)"
    + 称64位数为 "四字(quad word)"

+ C语言数据类型在X86-64中的大小

C声明   | Intel数据类型 | 汇编代码的后缀 | 大小(字节)
--------|---------------|----------------|--------------
char    | 字节          | b              | 1
short   | 字            | w              | 2
int     | 双字          | l              | 4
long    | 四字          | q              | 8
char *  | 四字          | q              | 8
float   | 单精度        | s              | 4
double  | 双精度        | l              | 8

+ 本章代码示例中大部分都是用了 指针 和 long数据类型, 所以都是四字操作
+ 大多数GCC生成的汇编代码指令都有一个字符的后缀, 表名操作数的大小
    + 例如: movb/movw/movl/movq


# 3.4 访问信息

+ p119 寄存器

+ x86-64 CPU 一组16个寄存器, 每个寄存器64位, 用来存储整数数据和指针

+ 有一组标准的编程规范控制着如何使用寄存器来管理栈, 传递函数参数, 从函数的返回值一级存储局部和临时变量...

## 3.4.1 操作数指示符

+ 大多数指令有一个或多个操作数(operand), 指示出一个操作数中要使用的 `源数据值` 以及 `放置结果的目的位置`

+ 源数据可以以常数形式给出, 或者从寄存器或内存中读出

+ 结果可以存放到寄存器或内存中

+ 各种不同操作数的可能性
    1. 立即数(immediate), 常数值
    2. 寄存器(register), 某个寄存器的内容
    3. 内存引用, 根据计算出来的地址访问某个位置

+ 寻址模式(p121)

+ 立即数偏移
+ 基址寄存器
+ 变址寄存器
+ 比例因子

+ 习题3.1 get

## 3.4.2 数据传送指令

+ 最常用的指令是将数据从一个位置复制到另一个位置的指令

+ 最简单的数据传送指令: MOV类, 他们把数据从源位置传送到目的位置, 不做任何变化

+ 源操作数指定的是一个立即数, 存在寄存器或者内存里
+ 目的操作数制定一个位置, 要么是寄存器, 要么是内存地址
+ x86-64加了一条限制: 传送指令的两个操作数不能都指向内存位置
    + i.e. 将一个值从内存地址1复制到内存地址2, 需要两条指令

+ TODO 问题: p123 "任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0" 是什么意思? 为什么?
+ TODO 问题: p123 "符号扩展"是什么意思
+ TODO 问题: p124 不明白旁注里的意思

`mov source, destination`

+ MOV指令的 元和目的类型的5种可能的组合(p123)
    1. 立即数 -> 寄存器
    2. 寄存器 -> 寄存器
    3. 内存   -> 寄存器
    4. 立即数 -> 内存
    5. 寄存器 -> 内存

+ movl $ox4050, %eax
    + 第一个是 源操作数
    + 第二个是 目的操作数

```s
movzbw
movzbl
movzwl
movzbq
movzwq
```

+ 每条指令的最后两个字符都是大小指示符
    + 第一个指示 源的大小
    + 第二个指示 目的地的大小

+ x86-64中的内存引用总是用四字长(64bit)寄存器给出, 例如 %rax, 哪怕操作数指示一个字节/一个字/一个双字(p227)
    + p120
    + p124 练习题 3.2

## 3.4.3 数据传送示例

+ cd csapp/ch03.程序的机器级表示 && make exchange_demo

+ %rdi 第1个参数
+ %rsi 第2个参数
+ ret  返回函数被调用点

+ https://stackoverflow.com/questions/42619995/running-assembly-code-for-mac-os-x
+ https://www.nasm.us/

+ [p125 example](./exchange.c)
+ csapp/ch03.程序的机器级表示/exchange_demo.c

```s
_exchange:                              ## @exchange
## %bb.0:
  pushq %rbp
  movq  %rsp, %rbp
  movq  (%rdi), %rax // mov指令 从内存中读值到寄存器
  movq  %rsi, (%rdi) // mov指令 从寄存器写值到内存
  popq  %rbp
  retq
                                        ## -- End function
```

+ TODO 问题: p126 习题3.4 看不明白

+ TODO 问题: p126 `pointer dereferencing` 是 "间接引用" 还是 "取消引用"?(./exchange.c)

+ 3.7 节讲函数调用和返回的细节

+ 参数通过寄存器传给函数

+ TODO p125 关于这段代码有 大大的疑惑...

+ p120 16个寄存器
    + %rbp 被调用者保存(???)
    + %rdi 第1个参数
    + %rsi 第2个参数
    + %rax 返回值

+ 像x这样的局部变量通常是保存在寄存器中, 而不是内存中; 访问寄存器比访问内存要快得多

+ OK 问题: 指令里, 有的寄存器加括号, 有的不加括号是什么意思?
    + AT & T assembly syntax: https://stackoverflow.com/questions/1619131/meaning-of-eax-in-att-syntax
    + 加括号表示从指针地址取值(p125)

+ TODO 问题: ad hoc 是 "特定"的意思吗?

## 3.4.4 压入和弹出栈数据

+ 栈顶元素的地址是所有栈中元素地址最低的
+ 栈指针%rsp 保存着栈顶元素的地址

+ 将数据压入程序栈
+ 从程序栈中弹出数据

+ pushq S 将4字压入栈
+ popq  D 将4字弹出栈

+ 将一个4字值压入栈中, 首先要将栈指针减8, 然后将值写到新的栈顶地址
+ 弹出一个四字的操作包括从栈顶位置读出数据, 然后将栈指针加8

+ 栈指针 %rsp (p120) 保存着栈顶元素的地址

+ x86-64中, 栈向低地址方向增长, 所以压栈是减小栈指针(寄存器%rsp)的值, 并将数据存放到内存中; 出栈是从内存中读数据, 并增加栈指针的值

# 3.5 算数和逻辑操作

+ 加减乘除
+ 取负
+ 左移位, 右移位
+ 异或
+ 与或非

## 3.5.1 加载有效地址

```bash
practice && cd csapp/ch03.程序的机器级表示/ && make scale_demo
```

+ leaq <=> lea q(4字) <=> Load Effective Address(加载有效地址) q


指令       |  效果       | 描述
-----------|-------------|-----------------
leaq S,D   |  D <--- &S  | 加载有效地址


+ 将有效地址 写入到 目的操作数
+ 这条指令可以为后面的内存应用产生指针
+ 另外, 它还可以间接地描述普通的算数操作(p129 有示例)
+ 目的操作数必须是寄存器

## 3.5.2 一元和二元操作

+ 一元操作的操作数只有一个, 它既是源又是目的; 这个操作数可以是一个寄存器, 也可以是一个内存地址

+ 二元操作的 第一个操作数是 源操作数; 第二个操作数 既是源又是目的

+ subq %rax, %rdx 读作 "从 %rdx 中减去 %rax"

## 3.5.3 移位操作

+ 先给出移位量, 在给出要移位的数
+ 移位量可以是立即数, 也可以是放在单字节寄存器%cl中


+ 大多数指令既可以用于无符号运算, 也可以用于补码运算; 只有右移操作要求区分有符号和无符号; 这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一(啥意思...)


# 3.6 控制

+ 机器代码 提供两种基本的低级机制来实现有条件的行为: 测试数据值, 然后根据测试的结果来改变控制流或数据流

## 3.6.1 条件码

+ CPU 维护着
    + 整数寄存器
    + 条件码(condition code)寄存器, 可以检测这些寄存器来执行条件分支指令

+ 常见的条件码: CF/ZF/SF/OF (p135)

+ 图3-10中的指令都会设置条件码

+ 有两类指令, 他们只设置条件码而不改变其他寄存器
    + CMP(与SUB指令一样)
    + TEST(与AND指令一样)

## 3.6.2 访问条件码

+ 注意到机器代码如何区分有符号 和 无符号值 很重要(p138)

## 3.6.3 跳转指令

+ 正常执行的情况下, 指令按照他们出现的顺序一条一条地执行
+ 跳转(jump)指令会导致执行切换到程序中一个全新的位置

+ 直接跳转
+ 间接跳转
+ 条件跳转(只能是直接跳转)


## 3.6.4 跳转指令的编码

+ 虽然我们不关心机器代码格式的细节, 但是理解跳转指令的目标如何编码, 对第7章理解链接非常重要; 此外特也能帮助理解反汇编器的输出

+ 问题: PC相对寻址是什么意思?

## 3.6.5 用条件控制来实现条件分支

+ TODO 问题: "有些条件可以用数据的条件转移实现, 而不是用控制的条件转移实现" 是什么意思...

## 3.6.6 用条件传送来实现条件分支

+ 实现条件操作的传统方法是通过使用该控制的条件转移. 当条件满足时 程序沿着一条执行路径执行, 反之去另一条路径; 这种机制简单而通用, 但在现代处理器上, 他可能会很低效(why? p146)

+ 一种替代的策略是使用数据的条件转移

+ 条件传送指令: 当传送条件满足时, 指令把源值S复制到目的R

+ 通过重叠连续指令的步骤来获取高性能

+ TODO 问题: p146 里提到的"分支预测"是什么意思?

+ 通条件跳转不同, 处理器无需预测测试的结果就可以执行条件传送; 处理器只是读源值, 检查条件码, 然后要么更新目的寄存器, 要么保持不变

+ 不是所有的条件表达式都可以用条件传送来编译(p147)

+ 使用条件传送也不总是会提高代码的效率; 编译器必须考虑浪费的计算和由于分支预测错误所造成的的性能处罚之间的相对性能

+ 总的来说, 条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略. 他们只适用于很受限的情况, 但这种情况还是很常见的, 而且与现代处理器的运行方式更加契合

## 3.6.7 循环

+ 汇编中没有相应的指令存在, 可以用条件测试和跳转组合起来实现循环的效果

+ do-while loop

+ 理解产生的汇编代码与原始源代码之间的关系, 关键是找到程序值和寄存器之间的映射关系

+ while loop
    + 翻译.1 跳转到中间(jump to middle p152), 它执行一个无条件跳转跳到循环结尾处的测试, 以此来执行初始的测试
    + 翻译.2 guarded-do, 首先用条件分支, 如果初始条件不成立, 就跳过循环, 把代码变换为do-while循环
+ for loop

## 3.6.8 switch 语句

+ 执行switch语句的关键步骤是通过跳转表来访问代码位置

# 3.7 过程

+ "过程"是软件中一种很重要的抽象, 它提供了一种封装代码的方式, 用一组指定的参数和毅哥可选的返回值实现了某种功能

+ 不同编程语言中, 过程的形式多样: 函数(function), 方法(method), 子例程(subroutine), 处理函数(handler)等等, 但他们有一些共有的特性

+ 传递控制/传递数据/分配和释放内存(p164)

+ 人们花费了大量的力气来尽量减少过程调用的开销; 所以它遵循了被认为是最低要求策略的方法, 只实现了上述机制中每个过程所必须的那些
+ 接下来 将一步步地构建起不同的机制, 先描述控制, 在描述数据传递, 最后是内存管理

## 3.7.1 运行时栈

+ 3.4.4节讲过, x86-64的栈向低地址方向增长, 而栈指针%rsp指向栈顶元素

+ 当x86-64过程需要的存储空间超出寄存器能够放的大小时, 就会在栈上分配空间; 这个部分称为 过程的栈帧(stack frame)

+ 当前正在执行的过程的帧总在栈顶

## 3.7.5 寄存器中的局部存储空间(重要)

+ 寄存器组是唯一被所有过程共享的资源

+ 可以这样来理解"调用者保存"这个名字: 过程P在某个此类寄存器中有局部数据, 然后调用过程Q; 因为Q可以随意修改这个寄存器, 所以在调用之前首先保存好这个数据是P(调用者)的责任

## 3.7.6 递归过程

+ 前面描述的寄存器和栈的惯例(p173)使得x86-64过程能够递归地调用他们自身; 每个过程调用在栈中都有他们自己的私有空间, 因此多个未完成调用的局部变量不会相互影响; 此外栈的原则很自然地就提供了适当的策略, 当过程被调用时分配局部存储, 当返回是释放存储

+ 从 ./rfact.c 这个例子可以看到, 递归调用一个函数本身与调用其他函数是一样的

+ 递归代码和我们看到的其他函数的结构一模一样; 栈和寄存器保存规则足以让递归函数正确执行

# 3.8 数组分配和访问














