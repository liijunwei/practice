+ 计算机执行机器代码, 用字节序列编码低级的操作, 包括
    + 处理数据
    + 管理内存
    + 读写存储设备上的数据
    + 利用网络通信

+ 本章中会近距离观察机器代码, 以及人类可读的表示---汇编代码

+ 通常情况下, 使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效

+ 高级语言编写的代码因为屏蔽了程序的的细节, 机器级的实现, 所以有较好的跨平台能力
+ 汇编代码则与特定机器密切相关

+ 能够阅读和理解汇编代码是一项重要技能: 编译器以汇编代码形式输出文件, 通过阅读这些汇编代码, 我们能够理解编译器的优化能力, 并分析代码中隐含的低效率
    + **试图最大化一段关键代码性能的程序员, 通常会尝试源代码的各种形式, 每次编译并检查产生的汇编代码, 从而了解程序将要运行的效率如何**

+ 程序员学习汇编语言的需求随着时间的推移也发生了变化, 开始时要求能直接用汇编语言编写程序, 现在则要求他们能够阅读和理解编译器产生的代码

+ 总览
    + C语言/汇编代码/机器代码之间的关系
    + x86-64的细节, 从数据的表示和处理以及控制的实现开始, 了解如何实现C语言中的控制结构(if/while/switch等)
    + 过程的实现, 如何维护一个运行栈来支持过程检数据和控制的传递, 局部变量的存储
    + 机器级怎么实现数组/结构/联合等数据结构
    + 内存越界问题
    + 使用GDB调试器检查机器级程序运行时行为的技巧
    + 包含浮点数据和操作的代码的及其程序表示


# 3.1 历史观点

+ 摩尔定律(Moore's Law)
    + 晶体管数量以每年大约37%的速率增加, 也就是说 晶体管数量没26个月就会翻一番
    + 1965年, 摩尔根据当时芯片技术做出推断, 预测未来十年, 芯片上的晶体管数量每年都会翻一番, 这个预测就成为摩尔定律

# 3.2 程序编码

## 3.2.1 机器级代码

+ 计算机系统使用了多种不同形式的抽象, 利用更简单的抽象模型来隐藏实现的细节

+ **对于机器级编程来说, 其中两种抽象尤为重要**:
    1. 由指令集体系结构或指令集架构(Instruction Set Architecture, ISA)来定义机器级程序的格式和行为, 它定义了处理器状态,指令的格式,每条指令对状态的影响
        + 大多数指令集架构(ISA) 将程序的行为描述成好像每条指令都是按顺序执行的, 一条指令结束后, 下一条才开始
        + 处理器的硬件远比描述的精细复杂, 他们并发地执行许多指令, 但是可以采取措施保证整体行为和ISA指定的顺序执行的行为完全一致
    2. 机器级程序使用的内存地址是虚拟地址, 提供的内存模型看上去是一个非常大的字节数组

ISA 指令集架构
ISA 指令集架构
ISA 指令集架构 指令集架构指令集架构指令集架构指令集架构

+ 机器代码, 二进制格式
+ 汇编代码, 文本格式

+ 汇编代码表示非常接近于机器代码. 与机器代码的二进制格式相比, 汇编代码的主要特点是他用可读性更好的文本格式表示;

+ 能够理解汇编代码以及它与原始C代码的联系, 是理解计算机如何执行程序的关键一步


p113
+ 程序计数器PC: 给出将要执行的下一条指令在内存中的地址
+ 整数寄存器文件: 存储地址/存储整数数据/记录程序状态/存储临时数据(参数/变量/返回值...)
+ 条件寄存器: 保存最近执行的算数或逻辑指令的状态信息, 实现程序中的 控制流
+ 一组向量寄存器: 存放一个或多个整数或者浮点数值

+ 程序内存包含什么部分(p114)

+ 一条机器指令只执行一个非常基本的操作

## 3.2.2 代码示例

csapp/ch03.程序的机器级表示/mstore.c

```bash
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -S mstore.c && cat mstore.s
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -c mstore.c && ls -al mstore.o
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -c mstore.c && objdump -d mstore.o

practice && cd csapp/ch03.程序的机器级表示/ && make main_demo
practice && cd csapp/ch03.程序的机器级表示/ && gcc -Og -o prog main.c mstore.c && objdump -d prog

```

+ 重要信息: 机器执行的程序只是一个字节序列, 它是对一系列指令的编码; 机器对产生这些指令的源代码几乎一无所知


## 3.2.3 关于格式的注解

```
_multstore:                             ## @multstore
## %bb.0:
  pushq %rbp                    # save %rbx
  movq  %rsp, %rbp              # copy dest to %rbx
  pushq %rbx
  pushq %rax
  movq  %rdx, %rbx
  callq _mult2                  # call mult2(x, y)
  movq  %rax, (%rbx)            # store result at *dest
  addq  $8, %rsp
  popq  %rbx                    # restore %rbx
  popq  %rbp
  retq                          # return
                                        ## -- End function
```

# 3.3 数据格式

+ 由于是从16位体系扩展成32位的, **Intel用术语"字(word)"表示16位数据类型**
+ 因此:
    + 称32位数为 "双字(double word)"
    + 称64位数为 "四字(quad word)"

+ C语言数据类型在X86-64中的大小

C声明   | Intel数据类型 | 汇编代码的后缀 | 大小(字节)
--------|---------------|----------------|--------------
char    | 字节          | b              | 1
short   | 字            | w              | 2
int     | 双字          | l              | 4
long    | 四字          | q              | 8
char *  | 四字          | q              | 8
float   | 单精度        | s              | 4
double  | 双精度        | l              | 8

+ 本章代码示例中大部分都是用了 指针 和 long数据类型, 所以都是四字操作
+ 大多数GCC生成的汇编代码指令都有一个字符的后缀, 表名操作数的大小
    + 例如: movb/movw/movl/movq


# 3.4 访问信息

+ p119 寄存器

+ x86-64 CPU 一组16个寄存器, 每个寄存器64位, 用来存储整数数据和指针

+ 有一组标准的编程规范控制着如何使用寄存器来管理栈, 传递函数参数, 从函数的返回值一级存储局部和临时变量...

## 3.4.1 操作数指示符

+ 大多数指令有一个或多个操作数(operand), 指示出一个操作数中要使用的 `源数据值` 以及 `放置结果的目的位置`

+ 源数据可以以常数形式给出, 或者从寄存器或内存中读出

+ 结果可以存放到寄存器或内存中

+ 各种不同操作数的可能性
    1. 立即数(immediate), 常数值
    2. 寄存器(register), 某个寄存器的内容
    3. 内存引用, 根据计算出来的地址访问某个位置

+ 寻址模式(p121)

+ 立即数偏移
+ 基址寄存器
+ 变址寄存器
+ 比例因子

+ 习题3.1 get

## 3.4.2 数据传送指令

+ 最常用的指令是将数据从一个位置复制到另一个位置的指令

+ 最简单的数据传送指令: MOV类, 他们把数据从源位置传送到目的位置, 不做任何变化

+ 源操作数指定的是一个立即数, 存在寄存器或者内存里
+ 目的操作数制定一个位置, 要么是寄存器, 要么是内存地址
+ x86-64加了一条限制: 传送指令的两个操作数不能都指向内存位置
    + i.e. 将一个值从内存地址1复制到内存地址2, 需要两条指令

+ TODO 问题: p123 "任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0" 是什么意思? 为什么?
+ TODO 问题: p123 "符号扩展"是什么意思
+ TODO 问题: p124 不明白旁注里的意思

`mov source, destination`

+ MOV指令的 元和目的类型的5种可能的组合(p123)
    1. 立即数 -> 寄存器
    2. 寄存器 -> 寄存器
    3. 内存   -> 寄存器
    4. 立即数 -> 内存
    5. 寄存器 -> 内存

+ movl $ox4050, %eax
    + 第一个是 源操作数
    + 第二个是 目的操作数

```s
movzbw
movzbl
movzwl
movzbq
movzwq
```

+ 每条指令的最后两个字符都是大小指示符
    + 第一个指示 源的大小
    + 第二个指示 目的地的大小

+ x86-64中的内存引用总是用四字长(64bit)寄存器给出, 例如 %rax, 哪怕操作数指示一个字节/一个字/一个双字(p227)
    + p120
    + p124 练习题 3.2

## 3.4.3 数据传送示例

+ cd csapp/ch03.程序的机器级表示 && make exchange_demo

+ %rdi 第1个参数
+ %rsi 第2个参数

+ https://stackoverflow.com/questions/42619995/running-assembly-code-for-mac-os-x
+ https://www.nasm.us/

+ [p125 example](./exchange.c)
+ csapp/ch03.程序的机器级表示/exchange_demo.c

```s
_exchange:                              ## @exchange
## %bb.0:
  pushq %rbp
  movq  %rsp, %rbp
  movq  (%rdi), %rax
  movq  %rsi, (%rdi)
  popq  %rbp
  retq
                                        ## -- End function
```

+ 参数通过寄存器传给函数

+ TODO p125 关于这段代码有 大大的疑惑...

+ p120 16个寄存器
    + %rbp 被调用者保存(???)
    + %rdi 第1个参数
    + %rsi 第2个参数
    + %rax 返回值

+ 像x这样的局部变量通常是保存在寄存器中, 而不是内存中; 访问寄存器比访问内存要快得多

+ OK 问题: 指令里, 有的寄存器加括号, 有的不加括号是什么意思?
    + AT & T assembly syntax: https://stackoverflow.com/questions/1619131/meaning-of-eax-in-att-syntax
    + 加括号表示从指针地址取值(p125)

+ TODO 问题: ad hoc 是 "特定"的意思吗?

## 3.4.4 压入和弹出栈数据

+ 将数据压入程序栈
+ 从程序栈中弹出数据

+ pushq S 将4字压入栈
+ popq  D 将4字弹出栈

+ 栈指针 %rsp (p120) 保存着栈顶元素的地址

+ 将一个4字值压入栈中, 首先要将栈指针减8, 然后将值写到新的栈顶地址

+ x86-64中, 栈向低地址方向增长, 所以压栈是减小栈指针(寄存器%rsp)的值, 并将数据存放到内存中; 出栈是从内存中读数据, 并增加栈指针的值

# 算数和逻辑操作

+ 加减乘除
+ 取负
+ 左移位, 右移位
+ 异或
+ 与或非

## 3.5.1 加载有效地址

```bash
practice && cd csapp/ch03.程序的机器级表示/ && make scale_demo
```

+ TODO 问题: 看不明白leaq的用法



till p149???


