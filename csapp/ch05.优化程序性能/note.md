20220808

+ 本章会探讨如何使用几种不同类型的程序优化技术, 使程序运行的更快

+ 编写高效的程序需要做到以下几点:
    1. 选择一组适当的算法和数据结构
    2. 编写出编译器能够有效优化, 以转换成高效可执行代码的源代码(理解优化编译器的能力和局限性非常重要; 有些编程语言比其他语言容易优化); 程序员经常能够以一种是编译器更容易产生高效代码的方式来编写他们的程序
    3. 针对处理运算量特别大的计算, 将一个任务分成多个部分, 这些部分可以在多核和多处理器的某种组合上并行地计算

+ 通常程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡

+ 理想情况下, 编译器能接受我们编写的任何代码并产生尽可能高效的/具有指定行为的机器级程序; 但是即使最好的编译器也受到`妨碍优化`(optimization blocker)的因素的阻碍, 妨碍优化的因素就是程序行为中那些严重依赖与执行环境的方面; 程序员必须编写容易优化的代码, 以帮助编译器

+ 程序优化的第1步: 消除不必要的工作, 让代码尽可能有效地执行所期望的任务
    + 包括 消除不必要的函数调用/条件测试/内存引用
+ 程序优化的第2步: 利用处理器提供的指令级病性能力(instruction-level parallelism), 同时执行多条指令

+ 代码剖析程序(profiler): 测量代码各部分性能的工具, 它能帮我们找到代码中低效率的部分, 并且确定程序中我们应该着重优化的部分

+ 研究程序的汇编代码表示也是理解编译器一级产生的代码会如何云心工单最有效手段之一

# 5.1 优化编译器的能力和局限性

+ "内存别名使用(memory aliasing)"

+ csapp/ch05.优化程序性能/twiddle_demo.c
    + make dangerous_twiddle_demo

+ 包含函数调用的代码可以用一个称为 "内联函数替换(inline substitution, 内联inlining)"的过程进行优化, 此时将函数调用替换为函数体

+ 在某些情况下, 最好组织编译器执行内联替换, 一种情况是用GDB调试时, 如果一个函数调用已经被内联替换优化过了, 那么任何对这个调用进行追踪或者设置断点的尝试都将失败(这个好像就是之前debug都失败了的原因...)

# 5.2 表示程序性能

+ 每元素的周期数(cycle per element, CPE)

# 5.3 程序示例

+ 有的变换 只能带来很小的性能提升, 而其他的能带来更巨大的效果

+ 根据我们的经验, 最好的方法是实验加上分析: 反复地尝试不同的方法, 进行测量, 并检查汇编代码表示以确定底层的性能瓶颈

+ 未经优化的代码是从C语言直接到机器代码的直接翻译, 通常效率明显较低; 简单的使用命令行选项"-O1", 就会进行一些基本的优化, 正如测试结果显示的那样, 程序员不需要做什么, 就会显著地提高程序性能---超过两个数量级; 通常 养成至少使用这个级别优化的习惯是很好的

# 5.4 消除循环的低效率

+ "代码移动(code motion)"

+ 优化编译器 会试着优化代码, 但是编译器通常会非常小心, 他们不能可靠的发现一个函数是否会有副作用, 因而假设函数会有副作用; 为了改进代码, 程序员必须经常帮助编译器显式地完成代码的移动

+ 一个看上去无足轻重的代码片段 有隐藏的渐进低效率(asymptotic inefficiency); 在大型编程项目中出现这样问题的故事比比皆是, 一个有经验的程序员工作的一部分就是避免引入这样一个渐进低效率



# 5.7 理解现代处理器

+ "目标机器的特性"

+ "指令级并行"

+ "关键路径" 制约程序的执行效率

+ 数据流表示中的关键路径提供的只是程序需要周期数的下界

# 5.8 循环展开

+ 循环展开是一种程序变换, 通过增加每次迭代计算的元素的数量, 减少循环的迭代次数

unclear







