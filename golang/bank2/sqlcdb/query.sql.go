// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sqlcdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAccount = `-- name: CreateAccount :one
insert into
  accounts(
    id,
    user_id,
    currency,
    available
  )
values
  (
    $1,
    $2,
    $3,
    $4
  ) returning id, user_id, currency, available, lock_version, created_at, updated_at
`

type CreateAccountParams struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	Currency  string    `json:"currency"`
	Available float64   `json:"available"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, createAccount,
		arg.ID,
		arg.UserID,
		arg.Currency,
		arg.Available,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Currency,
		&i.Available,
		&i.LockVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAccountEvent = `-- name: CreateAccountEvent :exec
insert into
  account_events(id, account_id, amount)
values
  ($1, $2, $3)
`

type CreateAccountEventParams struct {
	ID        uuid.UUID `json:"id"`
	AccountID uuid.UUID `json:"account_id"`
	Amount    float64   `json:"amount"`
}

func (q *Queries) CreateAccountEvent(ctx context.Context, arg CreateAccountEventParams) error {
	_, err := q.db.ExecContext(ctx, createAccountEvent, arg.ID, arg.AccountID, arg.Amount)
	return err
}

const createTransaction = `-- name: CreateTransaction :one
insert into
  transactions(
    id,
    from_account_id,
    to_account_id,
    amount,
    description,
    kind
  )
values
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
  ) returning id, from_account_id, to_account_id, amount, description, kind, created_at, updated_at
`

type CreateTransactionParams struct {
	ID            uuid.UUID `json:"id"`
	FromAccountID uuid.UUID `json:"from_account_id"`
	ToAccountID   uuid.UUID `json:"to_account_id"`
	Amount        float64   `json:"amount"`
	Description   string    `json:"description"`
	Kind          string    `json:"kind"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.ID,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.Amount,
		arg.Description,
		arg.Kind,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.Amount,
		&i.Description,
		&i.Kind,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into
  users(
    id,
    username,
    password,
    email
  )
values
  (
    $1,
    $2,
    $3,
    $4
  ) returning id, username, password, email, created_at, updated_at
`

type CreateUserParams struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
	Password string    `json:"password"`
	Email    string    `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.Password,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const creditAccount = `-- name: CreditAccount :one
update
  accounts
set
  available = available + $1,
  lock_version = lock_version + 1
where
  id = $2 returning id, user_id, currency, available, lock_version, created_at, updated_at
`

type CreditAccountParams struct {
	Amount float64   `json:"amount"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) CreditAccount(ctx context.Context, arg CreditAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, creditAccount, arg.Amount, arg.ID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Currency,
		&i.Available,
		&i.LockVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const debitAccount = `-- name: DebitAccount :one
update
  accounts
set
  available = available - $1,
  lock_version = lock_version + 1
where
  id = $2 returning id, user_id, currency, available, lock_version, created_at, updated_at
`

type DebitAccountParams struct {
	Amount float64   `json:"amount"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) DebitAccount(ctx context.Context, arg DebitAccountParams) (Account, error) {
	row := q.db.QueryRowContext(ctx, debitAccount, arg.Amount, arg.ID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Currency,
		&i.Available,
		&i.LockVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccount = `-- name: GetAccount :one
select
  id, user_id, currency, available, lock_version, created_at, updated_at
from
  accounts
where
  id = $1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Currency,
		&i.Available,
		&i.LockVersion,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllAccounts = `-- name: GetAllAccounts :many
select
  a.id account_id,
  u.username,
  u.email,
  a.currency,
  a.available,
  a.lock_version,
  a.created_at,
  a.updated_at
from
  users u
  join accounts a on u.id = a.user_id
order by
  u.username asc,
  a.currency asc,
  a.available desc
`

type GetAllAccountsRow struct {
	AccountID   uuid.UUID `json:"account_id"`
	Username    string    `json:"username"`
	Email       string    `json:"email"`
	Currency    string    `json:"currency"`
	Available   float64   `json:"available"`
	LockVersion int32     `json:"lock_version"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) GetAllAccounts(ctx context.Context) ([]GetAllAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAccountsRow
	for rows.Next() {
		var i GetAllAccountsRow
		if err := rows.Scan(
			&i.AccountID,
			&i.Username,
			&i.Email,
			&i.Currency,
			&i.Available,
			&i.LockVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
