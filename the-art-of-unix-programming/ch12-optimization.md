**多读几遍, 很短**


+ 关于性能优化, unix的经验告诉我们最主要的就是如何知道何时不去优化
+ 其次, 最有效的优化往往是优化之外的其他事情, 例如: 清晰干净的设计
+ 程序员工具箱中最强大的优化技术就是不做优化

+ **更明智的做法是 几种精力将时间复杂度/空间复杂度从O(n2) 降低至 O(n) 或者 O(nlog(n)), 或者类似的, 从一个更高次的指数将下来**, 线性性能增益往往很快就会被摩尔定律覆盖了

+ 另一个非常有建设性的"无为"方式就是不写代码

+ 问题: 12.4 里提到的 "最重要的问题是 尽量避免协议的往返" 是什么意思???

+ 有三种常规的策略来减少时延:
    1. 对可以共享启动开销的事物进行批处理
    2. 允许事务重叠(什么意思???) p293 还是没懂
    3. 缓存

+ 认为迫切需要缓存的时候, 明智的做法是 能够从更深的层次来考虑, 并问问为什么缓存是必须的; 这比将缓存的所有边界条件都考虑到要容易得多

+ Rob Pike 的6条原则(p12)
    1. 你无法断定程序会在什么地方耗费运行时间; 瓶颈经常出现在想不到的地方, 所以别急于胡乱找个地方改代码, 除非你已经证实了那儿就是瓶颈所在
    2. 估量; 在你没对代码进行估量, 特别是没找到最耗时的哪部分之前, 别去优化速度
    3. 花哨的算法在n很小时通常很慢, 而n通常很小; 花哨算法的常数复杂度很大; 除非你确定n总是很大, 否则不要用花哨算法(即使n很大, 也优先考虑原则2)
    4. 花哨的算法比简单算法更容易出bug, 更难实现; 尽量使用简单的算法配合简单的数据结构
    5. 数据压倒一切; 如果已经选择了正确的数据结构并且把一切都组织地井井有条, 正确的算法也就不言自明; 编程的核心是数据结构, 而不是算法
    6. 没有原则6

+ Ken Thompson 禅宗偈语般地对Pike的原则4做了强调: "拿不准就穷举"

+ 要用好性能剖析工具(profiler)
    + 使用profiler, 并不只是简单收集孤立的性能数字, 更应该把他当做一个具备许多有趣参数的函数(例如: 问题规模/CPU速度/磁盘速度/内存大小/编译优化/或其他相关因素)来研究性能是如何随之变化的, 这样, 才会有更多领悟

+ 最有效的带按摩油化方法就是保持代码短小简单
+ "永远不要八核心数据结构和时间关键循环抛出缓存"
    + unclear

