**多读几遍, 很短**


+ 关于性能优化, unix的经验告诉我们最主要的就是如何知道何时不去优化
+ 其次, 最有效的优化往往是优化之外的其他事情, 例如: 清晰干净的设计
+ 程序员工具箱中最强大的优化技术就是不做优化

+ **更明智的做法是 几种精力将时间复杂度/空间复杂度从O(n2) 降低至 O(n) 或者 O(nlog(n)), 或者类似的, 从一个更高次的指数将下来**, 线性性能增益往往很快就会被摩尔定律覆盖了

+ 另一个非常有建设性的"无为"方式就是不写代码

+ 使用profiler, 并不只是简单收集孤立的性能数字, 更应该把他当做一个具备许多有趣参数的函数(例如: 问题规模/CPU速度/磁盘速度/内存大小/编译优化/或其他相关因素)来研究性能是如何随之变化的, 这样, 才会有更多领悟

+ 问题: 12.4 里提到的 "最重要的问题是 尽量避免协议的往返" 是什么意思???

+ 有三种常规的策略来减少时延:
    1. 对可以共享启动开销的事物进行批处理
    2. 允许事务重叠(什么意思???) p293 还是没懂
    3. 缓存

+ 认为迫切需要缓存的时候, 明智的做法是 能够从更深的层次来考虑, 并问问为什么缓存是必须的; 这比将缓存的所有边界条件都考虑到要容易得多

+ Rob Pike 的6条法则(p12)
