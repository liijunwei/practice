模块性: 保持清晰, 保持简洁
================================

+ There are 2 ways of constructing a software design. One is make it so simple that there are obvisously no deficiencies(缺陷); the other is to make it so complicated that there are no obvious deficiencies. The first mothod is far more difficult
    + 软件设计有两种方式: 一种是设计的极为简洁, 没有看到明显的缺陷; 另一种是设计得极为复杂, 有缺陷也看不出来; 第一种方式难度要大的多

+ SPOT: Single Point Of Truth(p91 4.2.3)

+ 陈旧的缓存是滋生bug的温床

+ **要提高设计的紧凑性, 有一个精妙但强大的想法: 就是围绕"解决一个定义明确的问题"的强核心算法组织设计, 避免臆断和捏造**

+ p93 "diff的核心引擎小巧可靠, 没有一行代码需要维护" 啥意思? 完美了吗?

+ 主事件循环 -> 自顶向下
+ 主事件循环能调用的操作 -> 自底向上

+ "完美之道, 不在无可增加, 而在无可删减"

+ 这两节太精彩了
    + 4.5 unix和面向对象语言
    + 4.6 模块化编码

## 4.5 unix和面向对象语言

+ 跟其他正统领域相比, unix世界对OO语言的批判更直截了当; unix程序员知道什么时候不该用OO, 就算用OO, 他们也尽可能保持对象设计的整洁清晰

+ 正如"网络风格的元素"一书的作者在另一个略有不同的背景下所说的(Padlipshy): "如果你知道自己在做什么, 三层就够了; 但如果你不知道自己在做什么, 十七层也没用"

## 4.6 模块化编码

+ Hatton(p86) 图4.1

> 模块分解的越彻底, 每一块就越小, API 的定义也就越重要.全局复杂度和受 bug 影响的程度也会相应降低.然而, 也可能因过度划分造成模块太小.在模块很小时, bug 发生率也出乎意料地增多, 这在大量以不同语言实现的各种系统中均是如此.因此, Hatton 的经验数据表明, 假设其他所有因素(如程序员的能力)都相同, 200 到 400 之间的逻辑行的代码是"最佳点", 可能的缺陷密度达到最小.这个大小与所使用的语言无关 —— 这个结论有力支持了书中的建议, 即尽可能用最强大的语言和工具编程.根据经验, Hatton 建议逻辑行与物理行之间为两倍的折算率, 即最佳物理行数建议应在 400 至 800 行之间.

+ 模块性体现在良好的代码中, 但首先来自良好的设计
+ 在编写代码时, 问问自己以下这些问题, 可能会有助于提高代码的模块性:(p103)
    1. 有多少全局变量? 全局变量对模块化是毒药, 很容易使各模块轻率/混乱地互相泄露信息
    2. 单个模块的大小是否在Hatton的"最佳范围"内?(程序/模块代码行数)
    3. 模块内的单个函数是不是太大了? 与其说这是一个行数计算问题, 不如说是一个内部复杂性问题. 如果不能用一句话来简单描述一个函数与其调用程序之间的约定, 这个函数可能太大了
    4. 代码是不是有内部API(???)
    5. API的入口点是不是超过了7个? 有没有哪个类有七个以上的方法? 数据结构的成员是不是超过七个?
    6. 整个项目中每个模块的入口点数量如何分布? 是不是均匀? 有很多入口点的模块真的需要这么多入口点吗? 模块复杂性往往和入口点数量的平方成正比 --- 这也是简单API优于复杂API的另一个原因


