复杂度: 尽可能简单, 但别简单过了头
==========================================

+ 什么是"尽可能的简单"? 如何断定?

+ related: ./ch04-modularity.md

+ 复杂度的三个来源
    1. 实现的复杂度
    2. 程序界面的复杂度
    3. 系统中代码的总行数

+ Gabriel "Lisp: good news, bad news, and hot to win big"
    + unix和c语言具有病毒般的特性; 在软件设计发展过程的奋斗中, 哪些促成快速传播(传染)的特征, 如实现的简单性和可移植性, 比起设计的正确性和完备性更为有效
    + Gabriel的中心论点是关于 实现 和 接口 复杂度之间的一个精准权衡

+ 如果目标是抑制整体复杂度, 最愿意牺牲的是什么地方? 什么地方又最该被牺牲掉?

+ 对于本章(13.1.2)大多数问题, 良好品味和工程判断力要求, 情况不同, 则答案不同; 重要的是培养斟酌每一个设计的习惯. 正如我们在讨论软件模块性之前的建议一样, 复杂度的算盘一定要打好

+ 本质的/选择的/偶然的复杂度(13.1.3)

+ "仅10行程序, 再优雅也无法控制喷气飞机"(喷气飞机的复杂时必然的)

+ 为了看得更敏锐, 我们需要从注意 偶然复杂度 和 选择复杂度 的区别开始
    + 偶然复杂度的产生, 是因为没有找到实现规定功能集合的最简方法; 可以由良好的设计或者重新设计来去除
    + 选择复杂度, 通某个期望的功能相关联, 只能由改变工程的目标来去除

+ 这两者 好区分吗?


